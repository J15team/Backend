name: CD Deploy to AWS

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: j15-backend-dev
  ECS_CLUSTER: j15-backend-cluster-dev
  ECS_SERVICE: j15-backend-service-dev
  ECS_TASK_FAMILY: j15-backend-dev
  API_GATEWAY_ID: zu9mkxoir4

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Save current state for rollback
        id: save-state
        run: |
          echo "Saving current state for potential rollback..."
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].taskDefinition' \
            --output text)
          echo "current_task_def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          CURRENT_TASK_ARN=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --query 'taskArns[0]' \
            --output text)
          if [ "$CURRENT_TASK_ARN" != "None" ] && [ -n "$CURRENT_TASK_ARN" ]; then
            ENI_ID=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $CURRENT_TASK_ARN \
              --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
              --output text)
            CURRENT_IP=$(aws ec2 describe-network-interfaces \
              --network-interface-ids $ENI_ID \
              --query 'NetworkInterfaces[0].Association.PublicIp' \
              --output text)
            echo "current_ip=$CURRENT_IP" >> $GITHUB_OUTPUT
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"
          cache: gradle

      - name: Build application
        run: |
          chmod +x gradlew
          ./gradlew build --no-daemon -x test

      - name: Build and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          IMAGE_TAG="${{ github.sha }}"
          FULL_IMAGE="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          docker build --platform linux/amd64 -t $FULL_IMAGE .
          docker push $FULL_IMAGE
          docker tag $FULL_IMAGE ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest
          docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest
          echo "image=$FULL_IMAGE" >> $GITHUB_OUTPUT

      - name: Update ECS task definition
        id: update-task
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          aws ecs describe-task-definition \
            --task-definition $ECS_TASK_FAMILY \
            --query 'taskDefinition' > current-task-def.json
          NEW_IMAGE="${ECR_REGISTRY}/${ECR_REPOSITORY}:${{ github.sha }}"
          jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            current-task-def.json > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "new_task_def=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Deploy to ECS
        id: deploy-ecs
        run: |
          NEW_TASK_DEF="${{ steps.update-task.outputs.new_task_def }}"
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $NEW_TASK_DEF \
            --force-new-deployment

          echo "Waiting for new task with definition: $NEW_TASK_DEF"

          for i in {1..60}; do
            # å…¨ã¦ã®RUNNINGã‚¿ã‚¹ã‚¯ã‚’å–å¾—
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster $ECS_CLUSTER \
              --service-name $ECS_SERVICE \
              --desired-status RUNNING \
              --query 'taskArns' \
              --output text)
            
            for TASK_ARN in $TASK_ARNS; do
              # ã‚¿ã‚¹ã‚¯ã®è©³ç´°ã‚’å–å¾—
              TASK_INFO=$(aws ecs describe-tasks \
                --cluster $ECS_CLUSTER \
                --tasks $TASK_ARN \
                --query 'tasks[0].{def:taskDefinitionArn,status:lastStatus}' \
                --output json)
              
              TASK_DEF=$(echo $TASK_INFO | jq -r '.def')
              TASK_STATUS=$(echo $TASK_INFO | jq -r '.status')
              
              # æ–°ã—ã„ã‚¿ã‚¹ã‚¯å®šç¾©ã®ã‚¿ã‚¹ã‚¯ã‹ã¤RUNNINGã‹ç¢ºèª
              if [ "$TASK_DEF" == "$NEW_TASK_DEF" ] && [ "$TASK_STATUS" == "RUNNING" ]; then
                ENI_ID=$(aws ecs describe-tasks \
                  --cluster $ECS_CLUSTER \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                  --output text)
                NEW_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text)
                if [ -n "$NEW_IP" ] && [ "$NEW_IP" != "None" ]; then
                  echo "Found new task with IP: $NEW_IP"
                  echo "new_ip=$NEW_IP" >> $GITHUB_OUTPUT
                  exit 0
                fi
              fi
            done
            
            echo "Waiting for new task... ($i/60)"
            sleep 10
          done
          echo "Timeout waiting for new task"
          exit 1

      - name: Update API Gateway
        run: |
          NEW_IP="${{ steps.deploy-ecs.outputs.new_ip }}"
          INTEGRATION_ID=$(aws apigatewayv2 get-integrations \
            --api-id $API_GATEWAY_ID \
            --query 'Items[0].IntegrationId' \
            --output text)
          aws apigatewayv2 update-integration \
            --api-id $API_GATEWAY_ID \
            --integration-id $INTEGRATION_ID \
            --integration-uri "http://${NEW_IP}:8080/{proxy}"

      - name: Health check
        run: |
          API_URL=$(aws apigatewayv2 get-api \
            --api-id $API_GATEWAY_ID \
            --query 'ApiEndpoint' \
            --output text)
          NEW_IP="${{ steps.deploy-ecs.outputs.new_ip }}"

          echo "API URL: $API_URL"
          echo "Task IP: $NEW_IP"

          # ã‚¿ã‚¹ã‚¯IPã«ç›´æŽ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ç¢ºèª
          echo "Checking direct access to task..."
          sleep 60

          for i in {1..15}; do
            echo "Attempt $i/15"
            
            # ç›´æŽ¥IPã§ãƒã‚§ãƒƒã‚¯
            DIRECT_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${NEW_IP}:8080/actuator/health" --max-time 10 2>/dev/null || echo "000")
            echo "Direct IP check: HTTP $DIRECT_CODE"
            
            # API GatewayçµŒç”±ã§ãƒã‚§ãƒƒã‚¯
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/actuator/health" --max-time 10 || echo "000")
            echo "API Gateway check: HTTP $HTTP_CODE"
            
            if [ "$HTTP_CODE" == "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            sleep 20
          done

          echo "Health check failed after all retries"
          exit 1

      - name: Rollback on failure
        if: failure() && steps.save-state.outputs.current_task_def != ''
        run: |
          PREV_TASK_DEF="${{ steps.save-state.outputs.current_task_def }}"
          PREV_IP="${{ steps.save-state.outputs.current_ip }}"
          if [ -n "$PREV_TASK_DEF" ] && [ "$PREV_TASK_DEF" != "None" ]; then
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --task-definition $PREV_TASK_DEF \
              --force-new-deployment
          fi
          if [ -n "$PREV_IP" ] && [ "$PREV_IP" != "None" ]; then
            INTEGRATION_ID=$(aws apigatewayv2 get-integrations \
              --api-id $API_GATEWAY_ID \
              --query 'Items[0].IntegrationId' \
              --output text)
            aws apigatewayv2 update-integration \
              --api-id $API_GATEWAY_ID \
              --integration-id $INTEGRATION_ID \
              --integration-uri "http://${PREV_IP}:8080/{proxy}"
          fi

      - name: Summary
        if: success()
        run: |
          API_URL=$(aws apigatewayv2 get-api \
            --api-id $API_GATEWAY_ID \
            --query 'ApiEndpoint' \
            --output text)
          echo "## ðŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| é …ç›® | å€¤ |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| API URL | $API_URL |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.build-image.outputs.image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Task IP | ${{ steps.deploy-ecs.outputs.new_ip }} |" >> $GITHUB_STEP_SUMMARY
